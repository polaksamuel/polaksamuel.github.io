<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WeHa 07 Boyoz - Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#0b0e1a; --ink:#e9ecff; --card:#131735; --rim:#2b3170; --brand:#38d3ff; }
    body{font-family:Poppins,system-ui,sans-serif;background:var(--bg);color:var(--ink);
         display:flex;flex-direction:column;align-items:center;padding:20px}
    .card{background:var(--card);border:1px solid var(--rim);border-radius:20px;
          padding:26px;max-width:900px;width:100%;text-align:center;
          box-shadow:0 22px 50px rgba(0,0,0,.28)}
    h1{margin:0 0 16px}
    .stage{background:#0c0f22;border-radius:14px;padding:18px}
    canvas{width:100%; max-width:820px; height:auto; border-radius:12px; background:#0a0d20}
    input{width:90%;padding:10px;margin-top:14px;border-radius:10px;border:none}
    button{margin-top:14px;padding:12px 18px;border-radius:14px;border:none;
           background:var(--brand);color:#001022;font-weight:700;cursor:pointer}
    .feedback{margin-top:10px;font-weight:600}
    .section{margin-top:22px}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,.08);text-align:left}
    th{border-bottom:1px solid var(--rim);font-weight:700}
    .tag{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.08);
         border:1px solid rgba(255,255,255,.12);font-size:.8rem}
    #devBox{display:none;margin-top:16px;background:#222;padding:14px;border-radius:12px}
    #devBox label{display:block;margin:8px 0 4px}
    #devBox input[type="range"]{width:100%}
    #jsonOut{background:#111;color:#c9f0ff;padding:10px;border-radius:8px;overflow:auto}
    #dbg{position:fixed;left:12px;bottom:12px;background:#111;color:#9fe;padding:8px 10px;
         border:1px solid #2b3170;border-radius:10px;font:12px/1.2 monospace;max-width:70vw;opacity:.9}
  </style>
</head>
<body>
  <h1>üìù Guess Who?</h1>

  <div class="card">
    <h2 id="question">Who is this player?</h2>

    <div class="stage">
      <canvas id="canvas" width="820" height="520"></canvas>
    </div>

    <input id="answer" placeholder="Type your guess here">
    <div>
      <button id="submitBtn">Submit</button>
      <button id="nextBtn" style="display:none;margin-left:8px">Next (Random)</button>
    </div>
    <div id="feedback" class="feedback"></div>

    <div class="section">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">üèÜ Leaderboard</h3>
        <span id="playerCount" class="tag">0 players</span>
      </div>
      <table>
        <thead>
          <tr><th style="width:38%">Player</th><th style="width:32%">Last guess</th><th style="width:30%">Score</th></tr>
        </thead>
        <tbody id="leaderRows">
          <tr><td colspan="3" style="opacity:.8">No players yet.</td></tr>
        </tbody>
      </table>
    </div>

    <div id="devBox">
      <h3 style="margin:0 0 10px">üîß Dev crop controls (open page with <code>?dev=1</code>)</h3>
      <!-- explicit defaults so they don't sit in the middle -->
      <label>xPct <input id="xPct" type="range" min="0" max="1" step="0.01" value="0"></label>
      <label>yPct <input id="yPct" type="range" min="0" max="1" step="0.01" value="0"></label>
      <label>wPct <input id="wPct" type="range" min="0.05" max="1" step="0.01" value="1"></label>
      <label>hPct <input id="hPct" type="range" min="0.05" max="1" step="0.01" value="1"></label>
      <div style="margin-top:8px">Copy into Firestore <code>crop</code> map:</div>
      <pre id="jsonOut">{ "xPct": 0, "yPct": 0, "wPct": 1, "hPct": 1 }</pre>
    </div>
  </div>

  <div id="dbg" style="display:none"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
    import {
      getFirestore, doc, onSnapshot, setDoc, getDoc, getDocs, updateDoc,
      collection, onSnapshot as subColSnapshot
    } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC_YzaooeCA-VpI3gZgpQ7F3QoJzmlbe0s",
      authDomain: "weha07boyoz-game.firebaseapp.com",
      projectId: "weha07boyoz-game",
      storageBucket: "weha07boyoz-game.firebasestorage.app",
      messagingSenderId: "300785635491",
      appId: "1:300785635491:web:d3ef9caa6156a18788ef16"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const qEl = document.getElementById('question');
    const feedback = document.getElementById('feedback');
    const answerInput = document.getElementById('answer');
    const leaderRows = document.getElementById('leaderRows');
    const playerCountEl = document.getElementById('playerCount');
    const nextBtn = document.getElementById('nextBtn');
    const dbg = document.getElementById('dbg');

    const params = new URLSearchParams(window.location.search);
    const dev = params.has('dev');
    const isAdmin = params.has('admin');
    const devBox = document.getElementById('devBox');
    const xSlider = document.getElementById('xPct');
    const ySlider = document.getElementById('yPct');
    const wSlider = document.getElementById('wPct');
    const hSlider = document.getElementById('hPct');
    const jsonOut = document.getElementById('jsonOut');
    if (dev) { devBox.style.display = 'block'; dbg.style.display = 'block'; }
    if (isAdmin) nextBtn.style.display = 'inline-block';

    let playerId = localStorage.getItem('playerId');
    if (!playerId) { playerId = crypto.randomUUID(); localStorage.setItem('playerId', playerId); }
    let playerName = localStorage.getItem('playerName');
    if (!playerName) { playerName = prompt("Enter your name:") || "Player"; localStorage.setItem('playerName', playerName); }

    const roomRef = doc(db, "rooms", "game1");

    let dataCache = null;
    let imgCache = null;
    let devPreviewCrop = null;
    let unsubscribeRound = null;

    function log(...args){ console.log(...args); if(dev){ dbg.textContent = args.map(a=> (typeof a==='object'?JSON.stringify(a):String(a))).join(' ');} }

    function normalizeCrop(c) {
      const x = parseFloat(c?.xPct), y = parseFloat(c?.yPct);
      const w = parseFloat(c?.wPct), h = parseFloat(c?.hPct);
      return {
        xPct: Number.isFinite(x) ? x : 0,
        yPct: Number.isFinite(y) ? y : 0,
        wPct: (Number.isFinite(w) && w > 0) ? w : 1,
        hPct: (Number.isFinite(h) && h > 0) ? h : 1,
      };
    }

    function resolveImageUrl(s) {
      if (!s) return "";
      if (/^https?:\/\//i.test(s)) return s;
      return s.replace(/^\/+/, "");      // relative path preferred
    }

    // Tries both "page01.png" and "/page01.png"
    async function loadImageSmart(path) {
      const candidates = [resolveImageUrl(path), "/" + resolveImageUrl(path)];
      let lastErr;
      for (const url of candidates) {
        try {
          const img = await new Promise((res, rej) => {
            const im = new Image();
            im.onload = () => res(im);
            im.onerror = () => rej(new Error("Image failed: " + url));
            im.src = url;
          });
          log("[IMG OK]", url);
          return img;
        } catch (e) {
          lastErr = e; log("[IMG FAIL]", String(e.message));
        }
      }
      throw lastErr;
    }

    function draw() {
      if (!dataCache || !imgCache) return;
      const img = imgCache;
      const rawCrop = (dev && devPreviewCrop) ? devPreviewCrop : (dataCache.crop || {});
      let { xPct, yPct, wPct, hPct } = normalizeCrop(rawCrop);
      wPct = Math.min(wPct, 1 - xPct);
      hPct = Math.min(hPct, 1 - yPct);

      const W = img.naturalWidth, H = img.naturalHeight;
      const sx = Math.round(xPct * W), sy = Math.round(yPct * H);
      const sw = Math.max(1, Math.round(wPct * W)), sh = Math.max(1, Math.round(hPct * H));

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
    }

    function hydrateSlidersOnceFrom(crop) {
      if (!dev || !crop) return;
      xSlider.value = crop.xPct ?? 0;
      ySlider.value = crop.yPct ?? 0;
      wSlider.value = crop.wPct ?? 1;
      hSlider.value = crop.hPct ?? 1;
      devPreviewCrop = { xPct:+xSlider.value, yPct:+ySlider.value, wPct:+wSlider.value, hPct:+hSlider.value };
      jsonOut.textContent = JSON.stringify(devPreviewCrop, null, 2);
    }

    [xSlider,ySlider,wSlider,hSlider].forEach(sl => sl?.addEventListener('input', () => {
      devPreviewCrop = { xPct:+xSlider.value, yPct:+ySlider.value, wPct:+wSlider.value, hPct:+hSlider.value };
      jsonOut.textContent = JSON.stringify(devPreviewCrop, null, 2);
      draw();
    }));

    function _norm(s){ return (s||"").toLowerCase().trim().replace(/\s+/g," "); }
    function levenshtein(a,b){
      const m=[]; for(let i=0;i<=b.length;i++) m[i]=[i]; for(let j=0;j<=a.length;j++) m[0][j]=j;
      for(let i=1;i<=b.length;i++){ for(let j=1;j<=a.length;j++){
        m[i][j]= b[i-1]===a[j-1] ? m[i-1][j-1] : Math.min(m[i-1][j-1]+1,m[i][j-1]+1,m[i-1][j]+1);
      }} return m[b.length][a.length];
    }
    function isCorrect(target, guess){ const t=_norm(target), g=_norm(guess); if(!t||!g) return false; if(t===g) return true; return levenshtein(t,g)<=2; }

    async function showRoundDoc(roundId) {
      if (!roundId) return false;
      const rRef = doc(db, "rooms", "game1", "rounds", roundId);
      const snap = await getDoc(rRef);
      if (!snap.exists()) { log("[ROUND MISSING]", roundId); return false; }
      const d = snap.data();
      const url = d.pageImage || "";
      log("[ROUND]", roundId, "url:", url, "crop:", d.crop, "answer:", d.answer);

      try {
        const img = await loadImageSmart(url);
        dataCache = { crop: normalizeCrop(d.crop), answer: d.answer };
        imgCache = img;
        hydrateSlidersOnceFrom(dataCache.crop);
        draw();
      } catch (e) {
        log("[LOAD ERROR]", e.message);
        return false;
      }

      if (unsubscribeRound) unsubscribeRound();
      unsubscribeRound = onSnapshot(rRef, async (s2) => {
        if (!s2.exists()) return;
        const d2 = s2.data();
        try {
          const img2 = await loadImageSmart(d2.pageImage || "");
          dataCache = { crop: normalizeCrop(d2.crop), answer: d2.answer };
          imgCache = img2;
          draw();
        } catch (e) { log("[ROUND WATCH IMG FAIL]", e.message); }
      });

      return true;
    }

    onSnapshot(roomRef, async (roomSnap) => {
      if (!roomSnap.exists()) return;
      const room = roomSnap.data();
      qEl.textContent = room.question || "Who is this?";
      log("[ROOM]", { currentRoundId: room.currentRoundId, question: room.question });

      if (room.currentRoundId) {
        const ok = await showRoundDoc(room.currentRoundId);
        if (ok) return;
      }

      // Fallback (legacy)
      const url = room.pageImage || "";
      log("[FALLBACK ROOM-LEVEL]", url, room.crop);
      if (!url) return;
      try {
        const img = await loadImageSmart(url);
        dataCache = { crop: normalizeCrop(room.crop), answer: room.answer };
        imgCache = img;
        hydrateSlidersOnceFrom(dataCache.crop);
        draw();
      } catch (e) { log("[FALLBACK IMG FAIL]", e.message); }
    });

    document.getElementById('submitBtn').addEventListener('click', async () => {
      log("[SUBMIT] click");
      const guess = (answerInput.value || "").trim();
      if (!guess || !dataCache) return;
      const correct = isCorrect(dataCache.answer, guess);
      const points = correct ? 1 : 0;

      const playerRef = doc(db, "rooms", "game1", "Players", playerId);
      const pSnap = await getDoc(playerRef);
      const prev = (pSnap.exists() && typeof pSnap.data().score === "number") ? pSnap.data().score : 0;

      await setDoc(playerRef, {
        name: playerName, lastGuess: guess, lastResult: correct ? "‚úÖ":"‚ùå",
        score: prev + points, ts: Date.now()
      }, { merge: true });

      feedback.textContent = correct ? "‚úÖ Correct!" : "‚ùå Not quite.";
      setTimeout(()=> feedback.textContent="", 1500);
    });

    subColSnapshot(collection(db, "rooms", "game1", "Players"), (snap) => {
      const rows = []; let count = 0;
      snap.forEach(docSnap => {
        const p = docSnap.data() || {};
        const last = [p.lastGuess || "‚Äî", p.lastResult || ""].filter(Boolean).join(" ");
        rows.push(`<tr><td>${p.name||"(anon)"}</td><td>${last}</td><td>${typeof p.score==="number"?p.score:0}</td></tr>`);
        count++;
      });
      playerCountEl.textContent = `${count} ${count===1?"player":"players"}`;
      leaderRows.innerHTML = rows.length ? rows.join("") : `<tr><td colspan="3" style="opacity:.8">No players yet.</td></tr>`;
    });

    async function goToRandomRound() {
      const roundsCol = collection(db, "rooms", "game1", "rounds");
      const snap = await getDocs(roundsCol);
      const ids = snap.docs.map(d => d.id);
      if (!ids.length) return;
      const roomSnap = await getDoc(roomRef);
      const cur = roomSnap.data()?.currentRoundId;
      let nextId = ids[Math.floor(Math.random()*ids.length)];
      if (ids.length > 1) { while (nextId === cur) nextId = ids[Math.floor(Math.random()*ids.length)]; }
      await updateDoc(roomRef, { currentRoundId: nextId });
    }
    nextBtn?.addEventListener('click', goToRandomRound);
  </script>
</body>
</html>
