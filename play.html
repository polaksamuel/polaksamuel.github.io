<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Guess Who?</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#0b0e1a; --ink:#e9ecff; --card:#131735; --rim:#2b3170; --brand:#38d3ff; --mut:#94a3b8; --good:#43e27a; --warn:#ffd166; --bad:#ff597a; }
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,sans-serif;background:var(--bg);color:var(--ink);
         display:flex;flex-direction:column;align-items:center;padding:28px}
    .wrap{width:100%;max-width:940px}
    h1{margin:0 0 18px;text-align:center}
    .card{background:var(--card);border:1px solid var(--rim);border-radius:20px;padding:22px;
          box-shadow:0 22px 50px rgba(0,0,0,.28)}
    .stage{background:#0c0f22;border-radius:14px;padding:18px;margin-bottom:12px}
    canvas{width:100%;max-width:820px;height:auto;border-radius:12px;background:#0a0d20}
    .row{display:flex;gap:10px;align-items:center}
    input[type="text"]{flex:1;padding:11px 12px;border-radius:10px;border:none;background:#0e1228;color:var(--ink)}
    button{padding:11px 16px;border-radius:12px;border:1px solid #2b3170;background:var(--brand);color:#001022;font-weight:700;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #2b3170;background:#0c1026;font-size:.85rem;color:#bcd3ff}
    .section{margin-top:18px}
    .sub{color:var(--mut);font-size:.9rem}
    ul{margin:8px 0 0 18px}
    .ok{color:var(--good)} .fuzzy{color:var(--warn)} .bad{color:var(--bad)}
    #dbg{position:fixed;left:12px;bottom:12px;background:#111;color:#9fe;padding:8px 10px;
         border:1px solid #2b3170;border-radius:10px;font:12px/1.2 monospace;max-width:70vw;opacity:.9;display:none}

    /* Dev tools */
    #devBox{display:none;margin-top:16px;background:#111a28;padding:14px;border-radius:12px;border:1px solid #2b3170}
    #devBox label{display:block;margin:8px 0 4px}
    #devBox input[type="range"]{width:100%}
    #jsonOut{background:#0a0f22;color:#c9f0ff;padding:10px;border-radius:8px;overflow:auto}
    .saveRow{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üß© Guess Who?</h1>

    <div class="card">
      <div class="row" style="justify-content:space-between;margin-bottom:10px">
        <div>
          <span id="question" class="pill">Who is this player?</span>
        </div>
        <div>
          <span id="roundPill" class="pill">round: ‚Äî</span>
          <span id="timerPill" class="pill">‚è≥ 15s</span>
          <span id="phasePill" class="pill">guessing‚Ä¶</span>
        </div>
      </div>

      <div class="stage">
        <canvas id="canvas" width="820" height="520"></canvas>
      </div>

      <div class="row">
        <input id="answer" type="text" placeholder="Type your guess here">
        <button id="submitBtn">Submit</button>
      </div>
      <div id="feedback" class="sub" style="min-height:22px;margin-top:6px"></div>

      <div class="section">
        <h3 style="margin:0 0 6px">üìù All Answers</h3>
        <div id="answersWrap" class="sub">No guesses this round.</div>
      </div>

      <div class="section">
        <h3 style="margin:0 0 6px">üèÜ Leaderboard</h3>
        <div id="leaderWrap" class="sub">No scores yet.</div>
      </div>

      <!-- DEV TOOLS (only visible with ?dev=1) -->
      <div id="devBox">
        <h3 style="margin:0 0 10px">üîß Dev crop controls (open page with <code>?dev=1</code>)</h3>
        <label>xPct <input id="xPct" type="range" min="0" max="1" step="0.01" value="0"></label>
        <label>yPct <input id="yPct" type="range" min="0" max="1" step="0.01" value="0"></label>
        <label>wPct <input id="wPct" type="range" min="0.05" max="1" step="0.01" value="1"></label>
        <label>hPct <input id="hPct" type="range" min="0.05" max="1" step="0.01" value="1"></label>
        <div style="margin-top:8px">Copy into Firestore <code>crop</code> map:</div>
        <pre id="jsonOut">{ "xPct": 0, "yPct": 0, "wPct": 1, "hPct": 1 }</pre>

        <h4 style="margin:14px 0 6px">üíæ Save this crop as a new round</h4>
        <div class="saveRow">
          <input id="devAnswer" type="text" placeholder="Answer (e.g., Rosaline Abraham)">
          <input id="devImage" type="text" placeholder="pageImage URL (https://weha07boyoz.com/page01.png)">
        </div>
        <div class="row" style="margin-top:10px">
          <button id="saveRoundBtn">Save round</button>
          <span class="sub">New round ID will auto-pick the next like r00X.</span>
        </div>
        <div id="saveMsg" class="sub" style="margin-top:6px"></div>
      </div>
    </div>
  </div>

  <div id="dbg"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
    import {
      getFirestore, doc, onSnapshot, getDoc, setDoc, updateDoc, collection,
      addDoc, getDocs, serverTimestamp, deleteDoc, query, orderBy, limit, onSnapshot as subColSnapshot
    } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";

    /* ---------- CONFIG ---------- */
    const ROUND_DURATION_SEC = 15;
    const POINTS_EXACT = 10;
    const POINTS_FUZZY = 5;

    const firebaseConfig = {
      apiKey: "AIzaSyC_YzaooeCA-VpI3gZgpQ7F3QoJzmlbe0s",
      authDomain: "weha07boyoz-game.firebaseapp.com",
      projectId: "weha07boyoz-game",
      storageBucket: "weha07boyoz-game.firebasestorage.app",
      messagingSenderId: "300785635491",
      appId: "1:300785635491:web:d3ef9caa6156a18788ef16"
    };

    /* ---------- INIT ---------- */
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);
    const ROOM_ID = "game1";

    /* ---------- ELEMENTS ---------- */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const qEl = document.getElementById('question');
    const roundPill = document.getElementById('roundPill');
    const timerPill = document.getElementById('timerPill');
    const phasePill = document.getElementById('phasePill');
    const feedback = document.getElementById('feedback');
    const answerInput = document.getElementById('answer');
    const submitBtn = document.getElementById('submitBtn');
    const answersWrap = document.getElementById('answersWrap');
    const leaderWrap = document.getElementById('leaderWrap');
    const dbg = document.getElementById('dbg');

    // Dev
    const params = new URLSearchParams(location.search);
    const dev = params.has('dev');
    if (dev) document.getElementById('devBox').style.display = 'block';
    if (dev) dbg.style.display = 'block';
    const xSlider = document.getElementById('xPct');
    const ySlider = document.getElementById('yPct');
    const wSlider = document.getElementById('wPct');
    const hSlider = document.getElementById('hPct');
    const jsonOut = document.getElementById('jsonOut');
    const saveRoundBtn = document.getElementById('saveRoundBtn');
    const devAnswer = document.getElementById('devAnswer');
    const devImage = document.getElementById('devImage');
    const saveMsg = document.getElementById('saveMsg');

    function log(...a){ if(!dev) return; dbg.textContent = a.map(x => typeof x==='object' ? JSON.stringify(x) : String(x)).join(' '); console.log(...a); }

    /* ---------- IDENTITY ---------- */
    let playerId = localStorage.getItem('playerId');
    if (!playerId){ playerId = crypto.randomUUID(); localStorage.setItem('playerId', playerId); }
    let playerName = localStorage.getItem('playerName');
    if (!playerName){ playerName = prompt("Enter your name:") || "Player"; localStorage.setItem('playerName', playerName); }

    /* ---------- STATE ---------- */
    const roomRef = doc(db, "rooms", ROOM_ID);
    let roundState = { id:null, crop:null, answer:null, pageImage:null };
    let imgCache = null;
    let devPreviewCrop = null;
    let unsubGuesses = null, unsubPlayers = null;
    let alreadyGuessed = false;
    let phase = 'guess'; // 'guess' | 'reveal'
    let tStart = 0, tRemain = ROUND_DURATION_SEC, tHandle = null;

    // NEW: cache the rendered guesses so we can reveal instantly on phase flip
    let guessesHTML = 'No guesses this round.';

    /* ---------- HELPERS ---------- */
    function normalizeCrop(c) {
      const x = parseFloat(c?.xPct), y = parseFloat(c?.yPct);
      const w = parseFloat(c?.wPct), h = parseFloat(c?.hPct);
      return {
        xPct: Number.isFinite(x) ? x : 0,
        yPct: Number.isFinite(y) ? y : 0,
        wPct: (Number.isFinite(w) && w > 0) ? w : 1,
        hPct: (Number.isFinite(h) && h > 0) ? h : 1,
      };
    }
    function resolveImageUrl(s){ if(!s) return ""; if(/^https?:\/\//i.test(s)) return s; return s.replace(/^\/+/, ""); }
    function loadImage(url){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error("Image failed: "+url)); img.src=url; }); }
    function draw(){
      if (!imgCache) return;
      const raw = (dev && devPreviewCrop) ? devPreviewCrop : (roundState.crop || {});
      let {xPct,yPct,wPct,hPct} = normalizeCrop(raw);
      wPct = Math.min(wPct, 1-xPct); hPct = Math.min(hPct, 1-yPct);
      const W = imgCache.naturalWidth, H = imgCache.naturalHeight;
      const sx = Math.round(xPct*W), sy = Math.round(yPct*H);
      const sw = Math.max(1, Math.round(wPct*W)), sh = Math.max(1, Math.round(hPct*H));
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(imgCache, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
    }
    function setPhase(p){
      phase = p;
      phasePill.textContent = (p === 'guess') ? 'guessing‚Ä¶' : 'reveal';
    }

    /* ---------- FUZZY / SCORING ---------- */
    const _norm = s => (s||"").toLowerCase().trim().replace(/\s+/g," ");
    function levenshtein(a,b){
      const m=[]; for(let i=0;i<=b.length;i++) m[i]=[i]; for(let j=0;j<=a.length;j++) m[0][j]=j;
      for(let i=1;i<=b.length;i++) for(let j=1;j<=a.length;j++)
        m[i][j] = (b[i-1]===a[j-1]) ? m[i-1][j-1] : Math.min(m[i-1][j-1]+1, m[i][j-1]+1, m[i-1][j]+1);
      return m[b.length][a.length];
    }
    function judge(target, guess){
      const t = _norm(target), g=_norm(guess);
      if (!t || !g) return {kind:'wrong', points:0};
      if (t===g) return {kind:'exact', points:POINTS_EXACT};
      if (levenshtein(t,g) <= 2) return {kind:'fuzzy', points:POINTS_FUZZY};
      return {kind:'wrong', points:0};
    }

    /* ---------- TIMER ---------- */
    function startTimer(){
      if (tHandle) clearInterval(tHandle);
      tStart = Date.now();
      tRemain = ROUND_DURATION_SEC;
      timerPill.textContent = `‚è≥ ${tRemain}s`;
      setPhase('guess');
      submitBtn.disabled = alreadyGuessed ? true : false;
      answerInput.disabled = alreadyGuessed ? true : false;
      feedback.textContent = alreadyGuessed ? 'You already guessed this round. Waiting for reveal‚Ä¶' : '';
      answersWrap.textContent = 'Hidden until reveal‚Ä¶';
      tHandle = setInterval(()=>{
        const elapsed = Math.floor((Date.now()-tStart)/1000);
        const left = Math.max(ROUND_DURATION_SEC - elapsed, 0);
        tRemain = left;
        timerPill.textContent = `‚è≥ ${left}s`;
        if (left<=0){
          clearInterval(tHandle); tHandle=null;
          // Move to reveal
          setPhase('reveal');
          submitBtn.disabled = true;
          answerInput.disabled = true;
          // Immediately show whatever guesses we have so far
          answersWrap.innerHTML = guessesHTML || 'No guesses this round.';
        }
      }, 200);
    }

    /* ---------- RENDER ---------- */
    function renderLeaderboard(list){
      if (!list.length){ leaderWrap.textContent = 'No scores yet.'; return; }
      const rows = list
        .sort((a,b)=> (b.score||0)-(a.score||0) || (a.name||'').localeCompare(b.name||''))
        .map(p=>`${p.name||'Player'}: ${(p.score||0).toFixed(1)} pts`);
      leaderWrap.innerHTML = rows.map(r=>`<div>${r}</div>`).join('');
    }

    /* ---------- DEV SLIDERS ---------- */
    function hydrateSlidersFrom(crop){
      if (!dev || !crop) return;
      xSlider.value = crop.xPct ?? 0;
      ySlider.value = crop.yPct ?? 0;
      wSlider.value = crop.wPct ?? 1;
      hSlider.value = crop.hPct ?? 1;
      devPreviewCrop = { xPct:+xSlider.value, yPct:+ySlider.value, wPct:+wSlider.value, hPct:+hSlider.value };
      jsonOut.textContent = JSON.stringify(devPreviewCrop, null, 2);
      draw();
    }
    ;[xSlider,ySlider,wSlider,hSlider].forEach(sl=> sl?.addEventListener('input', ()=>{
      devPreviewCrop = { xPct:+xSlider.value, yPct:+ySlider.value, wPct:+wSlider.value, hPct:+hSlider.value };
      jsonOut.textContent = JSON.stringify(devPreviewCrop, null, 2);
      draw();
    }));

    /* ---------- ROOM / ROUND WIRING ---------- */
    async function subscribeToRound(roundId){
      if (!roundId) return;
      roundPill.textContent = `round: ${roundId}`;
      // load doc once
      const rRef = doc(db, "rooms", ROOM_ID, "rounds", roundId);
      const snap = await getDoc(rRef);
      if (!snap.exists()) return;
      const d = snap.data();
      roundState = { id: roundId, crop: normalizeCrop(d.crop), answer: d.answer, pageImage: d.pageImage };
      const url = resolveImageUrl(d.pageImage);
      log('[ROUND INIT]', {roundId, url, answer:d.answer, crop:d.crop});
      try{
        const img = await loadImage(url);
        imgCache = img;
        hydrateSlidersFrom(roundState.crop);
        draw();
      }catch(e){ log('[IMG FAIL]', e.message); }

      // one-guess-per-round: check if I already have a guess
      const myGuessRef = doc(db, "rooms", ROOM_ID, "rounds", roundId, "guesses", playerId);
      const myGuessSnap = await getDoc(myGuessRef);
      alreadyGuessed = myGuessSnap.exists();

      // guesses live (build HTML; reveal immediately if phase is reveal)
      if (unsubGuesses) unsubGuesses();
      const guessesCol = collection(db, "rooms", ROOM_ID, "rounds", roundId, "guesses");
      unsubGuesses = subColSnapshot(guessesCol, (qs)=>{
        const rows = [];
        qs.forEach(docSnap=>{
          const g = docSnap.data();
          const cls = g.kind==='exact' ? 'ok' : g.kind==='fuzzy' ? 'fuzzy' : 'bad';
          rows.push(`<li><span class="${cls}">${g.name||'Player'}: ${g.guess||'(blank)'}</span> ${g.kind==='exact'?'‚úÖ':g.kind==='fuzzy'?'üü®':'‚ùå'} <span class="sub">(${(g.points||0)} pts)</span></li>`);
        });
        guessesHTML = rows.length ? `<ul>${rows.join('')}</ul>` : 'No guesses this round.';
        if (phase === 'reveal'){
          answersWrap.innerHTML = guessesHTML;
        }else{
          answersWrap.textContent = 'Hidden until reveal‚Ä¶';
        }
      });

      // reset UI + start 15s timer on each new round
      answerInput.value = '';
      submitBtn.disabled = alreadyGuessed;
      answerInput.disabled = alreadyGuessed;
      feedback.textContent = alreadyGuessed ? 'You already guessed this round. Waiting for reveal‚Ä¶' : '';
      setPhase('guess');
      startTimer();
    }

    // Subscribe to room ‚Üí get currentRoundId
    onSnapshot(roomRef, async (roomSnap)=>{
      if (!roomSnap.exists()) return;
      const room = roomSnap.data();
      qEl.textContent = room.question || "Who is this player?";
      if (roundState.id !== room.currentRoundId){
        await subscribeToRound(room.currentRoundId);
      }
    });

    /* ---------- SUBMIT ---------- */
    submitBtn.addEventListener('click', async ()=>{
      if (phase !== 'guess') return;
      const guess = (answerInput.value || '').trim();
      if (!guess) return;
      if (!roundState.id) return;

      // enforce one guess by attempting to create (not overwrite) my doc
      const guessRef = doc(db, "rooms", ROOM_ID, "rounds", roundState.id, "guesses", playerId);
      const before = await getDoc(guessRef);
      if (before.exists()){
        alreadyGuessed = true;
        submitBtn.disabled = true;
        answerInput.disabled = true;
        feedback.textContent = 'Already submitted. Waiting for reveal‚Ä¶';
        return;
      }

      // judge + award points
      const j = judge(roundState.answer, guess);
      await setDoc(guessRef, {
        name: playerName,
        guess,
        kind: j.kind,            // 'exact' | 'fuzzy' | 'wrong'
        points: j.points,        // 10 / 5 / 0
        ts: Date.now()
      });

      // bump your total score (client-side for prototype)
      const myPlayerRef = doc(db, "rooms", ROOM_ID, "Players", playerId);
      const ps = await getDoc(myPlayerRef);
      const prev = (ps.exists() && typeof ps.data().score === 'number') ? ps.data().score : 0;
      await setDoc(myPlayerRef, {
        name: playerName,
        score: prev + j.points,
        lastGuess: guess,
        lastResult: j.kind,
        ts: Date.now()
      }, { merge: true });

      alreadyGuessed = true;
      submitBtn.disabled = true;
      answerInput.disabled = true;
      feedback.textContent = 'Locked! Your answer will be revealed when the timer ends.';
    });

    /* ---------- LEADERBOARD ---------- */
    if (unsubPlayers) unsubPlayers();
    unsubPlayers = subColSnapshot(collection(db, "rooms", ROOM_ID, "Players"), (qs)=>{
      const arr = [];
      qs.forEach(d=> arr.push(d.data()));
      renderLeaderboard(arr);
    });

    /* ---------- DEV: SAVE ROUND ---------- */
    saveRoundBtn?.addEventListener('click', async ()=>{
      const ans = (devAnswer.value||'').trim();
      const img = (devImage.value||'').trim();
      const crop = devPreviewCrop || roundState.crop || {xPct:0,yPct:0,wPct:1,hPct:1};
      if (!ans || !img){ saveMsg.textContent='Need answer + pageImage URL.'; return; }

      try{
        // find next r00X id
        const qs = await getDocs(collection(db, "rooms", ROOM_ID, "rounds"));
        const ids = qs.docs.map(d=>d.id);
        let max = 0; ids.forEach(id=>{ const m=/^r0*(\d+)$/.exec(id); if(m){ max = Math.max(max, parseInt(m[1],10)); }});
        const next = 'r' + String(max+1).padStart(3,'0');
        await setDoc(doc(db, "rooms", ROOM_ID, "rounds", next), {
          answer: ans,
          pageImage: img,
          crop
        });
        // (optional) jump to it so you can preview
        await updateDoc(roomRef, { currentRoundId: next });
        saveMsg.textContent = `Saved as ${next} and made active.`;
      }catch(e){
        console.error(e); saveMsg.textContent = 'Save failed (check rules / console).';
      }
    });

  </script>
</body>
</html>
